module Config --(readConfig, Config, host, token ) 
where

--наши модули
--import Error 
--import Parse 
--import Logic 
--import Types
--import Transformer 
--import App

import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString.Lazy.Char8 as LC
import Data.Aeson
import Control.Exception
import System.IO.Error (isDoesNotExistError)
--import GHC.Generics
import qualified Data.Map.Internal as M

import Control.Monad.Trans.Except
import Control.Monad.Trans.Class
import Control.Monad.State.Lazy
--трансформер в этот модуль импортировать нельзя, циклическая зависимость!!!

readConfig :: ExceptT E IO Config
readConfig = ExceptT $ do
    res <- toEE (L.readFile pathConfig) `catch` hR
    let config = res >>= runExcept . eDecode
    --print config
    return config

readConfig :: ExceptT E IO Config
readConfig = do
    res <-  ExceptT $ toEE (L.readFile pathConfig) `catch` hR
    o <-  toE $ getObject res
    config <- toE $ parseConfig o
    liftIO $ print config
    return config

readConfigValue :: ExceptT E IO Value
readConfigValue = do
    res <-  ExceptT $ toEE (L.readFile pathConfig) `catch` hR
    toE $ getValue res

pathConfig :: FilePath
pathConfig = "config.json"

hR :: IOException -> IO (EE L.ByteString )
hR e
    | isDoesNotExistError e = throw $ ConfigError "Файл конфигурации не найден!"
    | otherwise = throw $ ConfigError "Ошибка чтения файла конфигурации"

--эту же функцию можно использовать для сохранения других данных
--saveConfig :: ToJSON a => a -> ExceptT E IO ()
--saveConfig config = ExceptT $ toEE (L.writeFile pathConfig (encode config)) `catch` hW

saveConfig :: LC.ByteString -> ExceptT E IO ()
saveConfig config = ExceptT $ toEE (L.writeFile pathConfig config) `catch` hW

hW :: IOException -> IO (EE ())
hW e
    | isDoesNotExistError e = throw $ ConfigError "Файл конфигурации не найден!"
    | otherwise = throw $ ConfigError "Ошибка записи файла конфигурации"

--host :: String
--host="api.telegram.org"
--host="api.telegram.org"

--setUpdateId = undefined
--setUpdateId :: UpdateId -> Config -> Config
--setUpdateId newUid c = let newConfigApp = (configApp c) {updateId = newUid} in
--    c {configApp = newConfigApp}




setConfig :: ConfigFile -> Config -> ConfigFile
setConfig configFile config = let 
        configApps =  appsF configFile;
        newConfigApps = [configApp config] <> filter (\ca -> name ca /= name (configApp config) ) configApps in
    configFile {appsF = newConfigApps}

getConfig :: ConfigFile -> Config
getConfig configFile = let 
        configApps =  appsF configFile;
        configApp = head $ filter (\ca -> show (appF configFile) == name ca) configApps in 
    undefined


_parseConfig1 :: Object -> Parser Config
_parseConfig1 o = do 
    _appV <- o.: "app"
    app <- parseJSON _appV
    configTextO <- o .: "text"
    configApps <- _withArrayItem "apps"  parseJSONo o
    let configAppList = filter (\ac -> name ac == show app) configApps 
    case configAppList of
        [configApp] -> return Config {app = app, configApp = configApp, configText = configText}
        [] -> fail "Не найдено приложение в файле конфигурации"
        _ -> fail "Найдено более одного приложения в файле конфигурации"
    configText <- parseJSONo configTextO